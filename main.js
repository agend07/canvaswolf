// Generated by CoffeeScript 2.3.0
(function() {
  var Hero, Hit, Line, Point, Wall, buf8, canvasHeight, canvasWidth, cast, ctx, data, dec, draw, fpsSpan, hero, imageData, keys, pcast, project, render, round3, run, sizeX, world;

  sizeX = 45;

  canvasWidth = 0;

  canvasHeight = 0;

  ctx = null;

  data = null;

  buf8 = null;

  imageData = null;

  world = {
    ceiling: '111111111111111111111111111111111111111111111\n122223223232232111111111111111222232232322321\n122222221111232111111111111111222222211112321\n122221221232323232323232323232222212212323231\n122222221111232111111111111111222222211112321\n122223223232232111111111111111222232232322321\n111111111111111111111111111111111111111111111'.replace(/\s/g, ''),
    walling: '111111111111111111111111111111111111111111111\n100000000000000111111111111111000000000000001\n103330001111000111111111111111033300011110001\n103000000000000000000000000000030000030000001\n103330001111000111111111111111033300011110001\n100000000000000111111111111111000000000000001\n111111111111111111111111111111111111111111111'.replace(/\s/g, ''),
    floring: '111111111111111111111111111111111111111111111\n122223223232232111111111111111222232232322321\n122222221111232111111111111111222222211112321\n122222221232323323232323232323222222212323231\n122222221111232111111111111111222222211112321\n122223223232232111111111111111222232232322321\n111111111111111111111111111111111111111111111'.replace(/\s/g, '')
  };

  fpsSpan = document.getElementById("fps");

  keys = {};

  window.onkeyup = function(e) {
    return keys[e.keyCode] = false;
  };

  window.onkeydown = function(e) {
    return keys[e.keyCode] = true;
  };

  pcast = function(size, res, y) {
    return size / (2 * y - res);
  };

  dec = function(n) {
    return n % 1;
  };

  round3 = function(n) {
    return Math.round(n * 1000) / 1000;
  };

  Point = class Point {
    constructor(x1 = 0, y1 = 0) {
      this.x = x1;
      this.y = y1;
    }

    toString() {
      return `(${this.x}, ${this.y})`;
    }

    rag() {
      return new Point(-this.y, this.x);
    }

    add(other) {
      return new Point(this.x + other.x, this.y + other.y);
    }

    sub(other) {
      return new Point(this.x - other.x, this.y - other.y);
    }

    mul(n) {
      return new Point(this.x * n, this.y * n);
    }

    div(n) {
      return new Point(this.x / n, this.y / n);
    }

    mag() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }

    unt() {
      return this.div(this.mag());
    }

    slope() {
      return this.y / this.x;
    }

    turn(t) {
      var cosT, sinT;
      sinT = Math.sin(t);
      cosT = Math.cos(t);
      return new Point(this.x * cosT - this.y * sinT, this.x * sinT + this.y * cosT);
    }

    sh(b) {
      var x, y;
      x = b.x > 0 ? Math.floor(this.x + 1) : Math.ceil(this.x - 1);
      y = b.slope() * (x - this.x) + this.y;
      return new Point(x, y);
    }

    sv(b) {
      var x, y;
      y = b.y > 0 ? Math.floor(this.y + 1) : Math.ceil(this.y - 1);
      x = (y - this.y) / b.slope() + this.x;
      return new Point(x, y);
    }

    tile(tiles) {
      return tiles[Math.floor(this.x) + Math.floor(this.y) * sizeX] - '0';
    }

    cmp(b, c) {
      if (b.sub(this).mag() < c.sub(this).mag()) {
        return b;
      } else {
        return c;
      }
    }

  };

  Line = class Line {
    constructor(a = new Point(), b1 = new Point()) {
      this.a = a;
      this.b = b1;
    }

    rotate(t) {
      return new Line(this.a.turn(t), this.b.turn(t));
    }

    lerp(n) {
      return this.b.sub(this.a).mul(n).add(this.a);
    }

  };

  Hit = class Hit {
    constructor(tile1 = 0, where1 = new Point()) {
      this.tile = tile1;
      this.where = where1;
    }

  };

  Wall = class Wall {
    constructor(top1, bot1, size1) {
      this.top = top1;
      this.bot = bot1;
      this.size = size1;
    }

  };

  project = function(res, fov, corrected) {
    var bot, size, top;
    size = 0.5 * fov.a.x * res / corrected.x;
    top = (res - size) / 2;
    bot = (res + size) / 2;
    return new Wall(top < 0 ? 0 : Math.floor(top), bot > res ? Math.floor(res) : Math.floor(bot), size);
  };

  cast = function(where, direction, walling) {
    var delta, dx, dy, hit, ray, test, tmp;
    ray = where.cmp(where.sh(direction), where.sv(direction));
    delta = direction.mul(0.01); // point
    dx = new Point(delta.x, 0);
    dy = new Point(0, delta.y);
    tmp = delta;
    if (dec(ray.x) === 0) {
      tmp = dx;
    } else if (dec(ray.y) === 0) {
      tmp = dy;
    }
    test = ray.add(tmp);
    hit = new Hit(test.tile(walling), ray);
    if (hit.tile) {
      return hit;
    } else {
      return cast(ray, direction, walling);
    }
  };

  Hero = class Hero {
    constructor(fov1 = new Line(), where1 = new Point(), velocity = new Point(), speed = 0, acceleration1 = 0, theta = 0) {
      this.fov = fov1;
      this.where = where1;
      this.velocity = velocity;
      this.speed = speed;
      this.acceleration = acceleration1;
      this.theta = theta;
    }

    spin() {
      if (keys[37]) {
        this.theta -= 0.1; // LEFT
      }
      if (keys[39]) {
        this.theta += 0.1; // RIGHT
      }
      return this;
    }

    move() {
      var acceleration, direction, last, reference;
      last = hero.where;
      if (keys[38] || keys[40] || keys[88] || keys[90]) {
        reference = new Point(1, 0);
        direction = reference.turn(hero.theta);
        acceleration = direction.mul(hero.acceleration);
        if (keys[38]) {
          hero.velocity = hero.velocity.add(acceleration); // UP
        }
        if (keys[40]) {
          hero.velocity = hero.velocity.sub(acceleration); // DOWN
        }
        if (keys[88]) {
          hero.velocity = hero.velocity.add(acceleration.rag()); // X
        }
        if (keys[90]) {
          hero.velocity = hero.velocity.sub(acceleration.rag()); // Z
        }
      } else {
        hero.velocity = hero.velocity.mul(1 - hero.acceleration / hero.speed);
      }
      if (hero.velocity.mag() > hero.speed) {
        hero.velocity = hero.velocity.unt().mul(hero.speed);
      }
      hero.where = hero.where.add(hero.velocity);
      if (hero.where.tile(world.walling)) {
        hero.velocity = new Point(0, 0);
        hero.where = last;
      }
      return this;
    }

  };

  hero = new Hero(new Line(new Point(1, -1), new Point(1, 1)), new Point(3.5, 3.5), new Point(0, 0), 0.1, 0.01, 0); // fov // where // velocity // speed // acceleration // theta

  render = function(start) {
    var camera, column, corrected, fps, hit, i, j, k, l, ray, ref, ref1, ref2, ref3, ref4, ref5, tile, trace, wall, x, y;
    hero.spin();
    hero.move();
    camera = hero.fov.rotate(hero.theta);
    for (x = i = 0, ref = canvasWidth; (0 <= ref ? i < ref : i > ref); x = 0 <= ref ? ++i : --i) {
      column = camera.lerp(x / canvasWidth);
      hit = cast(hero.where, column, world.walling);
      ray = hit.where.sub(hero.where);
      corrected = ray.turn(-hero.theta);
      wall = project(canvasWidth, hero.fov, corrected);
      trace = new Line(hero.where, hit.where);
// ceiling
      for (y = j = 0, ref1 = wall.top; (0 <= ref1 ? j < ref1 : j > ref1); y = 0 <= ref1 ? ++j : --j) {
        tile = trace.lerp(-pcast(wall.size, canvasWidth, y + 0)).tile(world.ceiling);
        draw(x, y, tile);
      }
// wall
      for (y = k = ref2 = wall.top, ref3 = wall.bot; (ref2 <= ref3 ? k < ref3 : k > ref3); y = ref2 <= ref3 ? ++k : --k) {
        draw(x, y, hit.tile);
      }
// flooring
      for (y = l = ref4 = wall.bot, ref5 = canvasWidth; (ref4 <= ref5 ? l < ref5 : l > ref5); y = ref4 <= ref5 ? ++l : --l) {
        tile = trace.lerp(pcast(wall.size, canvasWidth, y + 1)).tile(world.floring);
        draw(x, y, tile);
      }
    }
    imageData.data.set(buf8);
    ctx.putImageData(imageData, 0, 0);
    fps = 1000 / (performance.now() - start);
    fpsSpan.innerHTML = round3(fps);
    return requestAnimationFrame(render);
  };

  draw = function(x, y, tile) {
    var idx;
    idx = y * canvasWidth + x;
    switch (tile) {
      case 1:
        return data[idx] = 0xFFAA0000;
      case 2:
        return data[idx] = 0xFF00AA00;
      case 3:
        return data[idx] = 0xFF0000AA;
    }
  };

  run = function() {
    var buf, canvas;
    canvas = document.getElementById('canvas');
    canvasWidth = canvas.width;
    canvasHeight = canvas.height;
    ctx = canvas.getContext('2d');
    imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
    buf = new ArrayBuffer(imageData.data.length);
    buf8 = new Uint8ClampedArray(buf);
    data = new Uint32Array(buf);
    return requestAnimationFrame(render);
  };

  run();

}).call(this);
